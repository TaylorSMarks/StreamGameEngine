<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>StreamGameEngine</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="LoadableMesh.js"></script>
    <script>
        const animations = {};
        const models = {};
        const countdowns = {};
        const texts = {};
        var playerId = "deadbeef-dead-4000-beef-cafebabedead";
        var adt = null;

        function welcome(data) {
            console.log(`welcome(${JSON.stringify(data)})`);
            playerId = data.playerId;
        }

        function updateCountdowns() {
            const now = Date.now();
            for (const countdown of Object.values(countdowns)) {
                if (countdown.endAt) {
                    countdown.textbox.text = ((countdown.endAt - now) / 1000).toFixed(2);
                }
            }
        }

        function addModel(data) {
          console.log(`addModel(${JSON.stringify(data)})`);
          const name = `Model_${data.id}`;
          const newModel = (data.mesh === "sphere") ? BABYLON.MeshBuilder.CreateSphere(name) : new LoadableMesh(name, data.mesh);
          models[data.id] = newModel;
          console.log(`model created with id ${data.id}`);
          newModel.position = new BABYLON.Vector3(data.x, data.y, data.z);
          newModel.material = new BABYLON.StandardMaterial(`Material_${data.id}`);
          newModel.material.diffuseColor = BABYLON.Color3.FromHexString(data.color);

          if (data.clickable) {
            newModel.actionManager = new BABYLON.ActionManager();
            newModel.actionManager.registerAction(
              new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                function() { fetch(`/clickModel/${playerId}/${data.id}`); }
            ));
          }
        }

        function moveModel(data) {
          console.log(`moveModel(${JSON.stringify(data)})`);
          const model = models[data.id];
          const fps = 30;
          const frames = fps * data.duration;
          if (animations[data.id]) {
              animations[data.id].stop();
          }
          animations[data.id] = BABYLON.Animation.CreateAndStartAnimation(`Move_Model_${data.id}`, model, 'position', fps, frames, model.position, new BABYLON.Vector3(data.x, data.y, data.z), BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
        }

        function removeModel(data) {
          models[data.id].dispose();
          delete models[data.id];
          delete animations[data.id];
        }

        function addCountdown(data) {
            console.log(`addCountdown(${JSON.stringify(data)})`);
            // TODO: Factor in the positioning info that's passed in...
            // TODO: Continually update the displayed amount of time left...
            const text = new BABYLON.GUI.TextBlock();
            text.text = "Hello world";
            text.color = "white";
            text.fontSize = 24;
            text.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            text.top = 0;
            text.height = "24px";
            countdowns[data.id] = {
                textbox: text,
                endAt: null
            };
            adt.addControl(text);
        }

        function changeCountdown(data) {
            console.log(`changeCountdown(${JSON.stringify(data)})`);
            countdowns[data.id]['endAt'] = data.endAt;
        }

        function addText(data) {
            console.log(`addText(${JSON.stringify(data)})`);
            const text = new BABYLON.GUI.TextBlock();
            text.text = data.text;
            text.color = "white";
            text.fontSize = 24;
            text.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            text.top = `${data.y}%`;
            text.left = `${data.x}%`;
            text.height = (data.text.split("\n").length * 24) + "px";
            texts[data.id] = text;
            adt.addControl(text);
        }

        function changeText(data) {
            console.log(`changeText(${JSON.stringify(data)})`);
            texts[data.id].text = data.text;
        }

        window.addEventListener('load', function() {
          const canvas = document.getElementById("renderCanvas");
          const engine = new BABYLON.Engine(canvas, true);
          const scene = new BABYLON.Scene(engine);

          const cameraTarget = new BABYLON.Vector3(3, 3, 0);
          const cameraDistance = 10;  // Maybe too close for phones in landscape? Used to be 15...
          new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, cameraDistance, cameraTarget);
          // If you wanted it to be rotatable...
          //camera.attachControl(canvas, true);

          new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

          adt = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

          engine.runRenderLoop(function () {
              updateCountdowns();
              scene.render();
          });

          // Watch for browser/canvas resize events
          window.addEventListener("resize", function () {
              engine.resize();
          });

          const eventSource = new EventSource("event-stream");
          eventSource.addEventListener("addModel",        (event) => { addModel       (JSON.parse(event.data)); });
          eventSource.addEventListener("moveModel",       (event) => { moveModel      (JSON.parse(event.data)); });
          eventSource.addEventListener("removeModel",     (event) => { removeModel    (JSON.parse(event.data)); });
          eventSource.addEventListener("addCountdown",    (event) => { addCountdown   (JSON.parse(event.data)); });
          eventSource.addEventListener("changeCountdown", (event) => { changeCountdown(JSON.parse(event.data)); });
          eventSource.addEventListener("addText",         (event) => { addText        (JSON.parse(event.data)); });
          eventSource.addEventListener("changeText",      (event) => { changeText     (JSON.parse(event.data)); });
          eventSource.addEventListener("welcome",         (event) => { welcome        (JSON.parse(event.data)); });
        });
    </script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
</body>
</html>